#!/bin/sh

LABNAME="vxlan"

# Choose one variant:
#VARIANT=multicast
#VARIANT=unicast-static-default
#VARIANT=unicast-static-l2
#VARIANT=unicast-static-nd
#VARIANT=unicast-static-rsc
VARIANT=unicast-dynamic-l2

cd "$(dirname "$(readlink -f "$0")")"
. ../common/lab-setup

# Network 1 is the underlay network. We consider it as a routed L3
# network, but we lie a bit.
spawn vm S1 networks 1,2
spawn vm S2 networks 1,3,4
spawn vm S3 networks 1,5

spawn vm H1 network 2
spawn vm H2 network 3
spawn vm H3 network 4
spawn vm H4 network 5

run

noip() {
    # Linux have IP enabled on all interfaces and it cannot be
    # disabled for IPv4. Let's use iptables when we want to disable IP
    # processing on an interface. ARP requests will still be
    # processed. Don't try to be too smart, the goal is just to avoid
    # the switches to answer to some multicast traffic.
    iptables -I INPUT -i $1 -j DROP
    ip6tables -I INPUT -i $1 -j DROP
}

# Executed on each VM
case $uts in
    H*)
        # With the unicast-static-rsc variant, we want to "route"
        # traffic directly between two subnets by using switching. We
        # put H1 and H4 on different subnets. They should use some
        # router which doesn't exist.
        case $uts,$VARIANT in
            H1,unicast-static-rsc)
                ip -6 addr add 2001:db8:ff::10/64 dev eth0
                ip -6 route add default via 2001:db8:ff::1
                ip -6 neigh add 2001:db8:ff::1 lladdr 02:00:00:00:00:01 dev eth0 # doesn't exist
                ;;
            H4,unicast-static-rsc)
                ip -6 addr add 2001:db8:fe::13/64 dev eth0
                ip -6 route add default via 2001:db8:fe::1
                ip -6 neigh add 2001:db8:fe::1 lladdr 02:00:00:00:00:02 dev eth0 # doesn't exist
                ;;
            *,*)
                ip -6 addr add 2001:db8:ff::$(( ${uts#H} + 9 ))/64 dev eth0
                ;;
        esac
        service nginx
        ;;
    S*)
        # Setup the "routed" underlay network
        # On lo, an IPv6 loopback address would be marked as
        # "unreachable" (and not considered by BIRD). Therefore, we put it on dummy0.
        ip -6 addr add 2001:db8:${uts#S}::1/128 dev dummy0
        service bird

        brctl addbr br0
        brctl setfd br0 0
        for iface in /sys/class/net/eth*; do
            [ -d $iface ] || continue
            iface=${iface##*/}
            case $iface in
                eth0) ;;
                *)
                    brctl addif br0 $iface
                    noip $iface
                    ;;
            esac
        done

        case $VARIANT in
            multicast)
                # VXLAN configuration using multicast
                ip link add vxlan0 type vxlan \
                   dstport 4789 \
                   id 100 \
                   ttl 5 \
                   group ff05::100 \
                   dev eth0 \
                   local 2001:db8:${uts#S}::1
                ;;
            unicast-static-default)
                # VXLAN configuration using unicast flooding.
                ip -6 link add vxlan0 type vxlan \
                   dstport 4789 \
                   id 100 \
                   ttl 5 \
                   local 2001:db8:${uts#S}::1
                ;;
            unicast-static-l2)
                # Same as previously, but we disable learning as we
                # don't expect any additional entries (this could
                # protect us from some exhaustion attack).
                ip -6 link add vxlan0 type vxlan \
                   dstport 4789 \
                   id 100 \
                   ttl 5 \
                   local 2001:db8:${uts#S}::1 \
                   nolearning
                ;;
            unicast-static-nd)
                # Same as previously, but we enable proxy mode to reduce ARP/ND traffic.
                ip -6 link add vxlan0 type vxlan \
                   dstport 4789 \
                   id 100 \
                   ttl 5 \
                   local 2001:db8:${uts#S}::1 \
                   nolearning \
                   proxy

                # Static neighbor entries to reduce neighbors discovery.
                [ ${uts#S} = 1 ] || ip -6 neigh add 2001:db8:ff::10 lladdr 50:54:33:00:00:08 dev vxlan0
                [ ${uts#S} = 2 ] || ip -6 neigh add 2001:db8:ff::11 lladdr 50:54:33:00:00:09 dev vxlan0
                [ ${uts#S} = 2 ] || ip -6 neigh add 2001:db8:ff::12 lladdr 50:54:33:00:00:0a dev vxlan0
                [ ${uts#S} = 3 ] || ip -6 neigh add 2001:db8:ff::13 lladdr 50:54:33:00:00:0b dev vxlan0
                ;;
            unicast-static-rsc)
                # Same as unicast-static-default but we use a route
                # short circuit to let H1 and H4 communicate despite
                # the absence of router (so, for H1/H4, the setup is
                # more similar to unicast-static-nd).
                ip -6 link add vxlan0 type vxlan \
                   dstport 4789 \
                   id 100 \
                   ttl 5 \
                   local 2001:db8:${uts#S}::1 \
                   rsc

                [ ${uts#S} != 1 ] || bridge fdb append 02:00:00:00:00:01 dev vxlan0 dst 2001:db8:10::1 router
                [ ${uts#S} != 3 ] || bridge fdb append 02:00:00:00:00:02 dev vxlan0 dst 2001:db8:10::1 router
                [ ${uts#S} != 1 ] || ip -6 neigh add 2001:db8:fe::13 lladdr 50:54:33:00:00:0b dev vxlan0
                [ ${uts#S} != 3 ] || ip -6 neigh add 2001:db8:ff::10 lladdr 50:54:33:00:00:08 dev vxlan0
                ;;
            unicast-dynamic-l2)
                # No default FDB rules but uses a simplistic custom
                # controller to register entries when they are needed.
                ip -6 link add vxlan0 type vxlan \
                   dstport 4789 \
                   id 100 \
                   ttl 5 \
                   local 2001:db8:${uts#S}::1 \
                   nolearning \
                   l2miss

                # We still need ARP/ND to work. We register (broadcast
                # and) multicast addresses. That's quite a limitation
                # of this solution.
                [ ${uts#S} = 1 ] || bridge fdb append 33:33:FF:00:00:10 dev vxlan0 dst 2001:db8:1::1
                [ ${uts#S} = 2 ] || bridge fdb append 33:33:FF:00:00:11 dev vxlan0 dst 2001:db8:2::1
                [ ${uts#S} = 2 ] || bridge fdb append 33:33:FF:00:00:12 dev vxlan0 dst 2001:db8:2::1
                [ ${uts#S} = 3 ] || bridge fdb append 33:33:FF:00:00:13 dev vxlan0 dst 2001:db8:3::1

                # Now, ip monitor will display stuff like this:
                # miss dev vxlan0 lladdr 50:54:33:00:00:08 STALE
                # Then, we have to add the entry (with bridge fdb).

                # As a PoC, we use a shell script for this purpose,
                # but of course, this should be done by something more
                # robust.
                (
                    ip monitor neigh dev vxlan0 | while read miss lladdr mac remaining; do
                        case $miss,$lladdr in
                            miss,lladdr) ;;
                            *) continue
                        esac
                        # The list of entries is hard-coded in the
                        # script. You should use a registry instead or
                        # some way to let VTEP share their local FDB
                        # with their peers.
                        case $mac in
                            50:54:33:00:00:08) dst=2001:db8:1::1 ;;
                            50:54:33:00:00:09) dst=2001:db8:2::1 ;;
                            50:54:33:00:00:0a) dst=2001:db8:2::1 ;;
                            50:54:33:00:00:0b) dst=2001:db8:3::1 ;;
                            *) continue ;;
                        esac
                        bridge fdb replace $mac dev vxlan0 dst $dst dynamic
                    done
                ) &
                ;;
        esac
        case $VARIANT in
            unicast-static-default|unicast-static-l2|unicast-static-rsc)
                # Any BUM frame will be sent to the other hosts. We
                # need that even for static L2 as we will have
                # broadcast/multicast frames for neighbors discovery
                # (ARP/ND). Not strictly needed for unicast static L3
                # case (but no broadcast will be possible then).
                [ ${uts#S} = 1 ] || bridge fdb append 00:00:00:00:00:00 dev vxlan0 dst 2001:db8:1::1
                [ ${uts#S} = 2 ] || bridge fdb append 00:00:00:00:00:00 dev vxlan0 dst 2001:db8:2::1
                [ ${uts#S} = 3 ] || bridge fdb append 00:00:00:00:00:00 dev vxlan0 dst 2001:db8:3::1
        esac
        case $VARIANT in
            unicast-static-l2|unicast-static-nd)
                # We put static entries for known mac.
                [ ${uts#S} = 1 ] || bridge fdb append 50:54:33:00:00:08 dev vxlan0 dst 2001:db8:1::1
                [ ${uts#S} = 2 ] || bridge fdb append 50:54:33:00:00:09 dev vxlan0 dst 2001:db8:2::1
                [ ${uts#S} = 2 ] || bridge fdb append 50:54:33:00:00:0a dev vxlan0 dst 2001:db8:2::1
                [ ${uts#S} = 3 ] || bridge fdb append 50:54:33:00:00:0b dev vxlan0 dst 2001:db8:3::1
                ;;
        esac

        noip vxlan0
        noip br0
        brctl addif br0 vxlan0
        ip link set up dev vxlan0
        ip link set up dev br0
        ;;
esac
