#!/bin/sh

LABNAME="l3-hyperv"

cd "$(dirname "$(readlink -f "$0")")"
. ../common/lab-setup

spawn vm HV1 networks 1,8,9
spawn vm VM1 network 1
spawn vm VM2 network 1

spawn vm HV2 networks 2,8,9
spawn vm VM3 network 2

spawn vm HV3 networks 3,8,9
spawn vm VM4 network 3

spawn vm internet networks 8,9

spawn vm RR1 network 8
spawn vm RR2 network 9

run

case $uts in
    HV*)
        # We add some VLAN
        ip link add name eth1.private link eth1 type vlan id 20
        ip link add name eth2.private link eth2 type vlan id 20
        ip link add name eth1.public link eth1 type vlan id 90
        ip link add name eth2.public link eth2 type vlan id 90
        ip link set up dev eth1.private
        ip link set up dev eth2.private
        ip link set up dev eth1.public
        ip link set up dev eth2.public

        # Fake router IP for VM
        ip addr add 203.0.113.254/32 dev eth0
        # For IPv6, this is not needed, but in case someone wants to
        # configure IPv6 manually, we provide a fixed router address.
        ip -6 addr add 2001:db8:cb00:7100::fe/128 dev eth0

        # IP used for ECMP routing
        ip addr add 198.51.100.10${uts#HV}/25 dev eth1.public
        ip addr add 198.51.100.20${uts#HV}/25 dev eth2.public
        ip addr add 172.22.15.10${uts#HV}/25 dev eth1.private
        ip addr add 172.22.15.20${uts#HV}/25 dev eth2.private
        ip -6 addr add 2001:db8:c633:6400::${uts#HV}/120 dev eth1.public
        ip -6 addr add 2001:db8:c633:6401::${uts#HV}/120 dev eth2.public

        # Own IP for private purpose
        ip addr add 172.22.2.${uts#HV}/32 dev eth0
        ip route add 172.22.2.${uts#HV}/32 dev eth0 table 20

        # Some firewall rules as a second level of defense. We could
        # go stateless if we needed to. Another line of defense would
        # be to use containers to get distinct domain of
        # routing. However, it would mean for the orchestrator to also
        # be able to work with containers.
        ip46tables() {
                iptables "$@" && ip6tables "$@"
        }
        for iface in eth1.public eth2.public; do
                ip46tables -A FORWARD -i eth0 -o $iface -j ACCEPT
                ip46tables -A FORWARD -i $iface -o eth0 -j ACCEPT
                ip46tables -A FORWARD -i $iface -o eth1.public -j ACCEPT
                ip46tables -A FORWARD -i $iface -o eth2.public -j ACCEPT
        done
        ip46tables -A FORWARD -i eth0 -o eth0 -j ACCEPT
        ip46tables -A FORWARD -m limit --limit 5/s --limit-burst 5 \
                   -j LOG --log-prefix "NF: routing evasion: " --log-level warning
        ip46tables -A FORWARD -j DROP

        # RP filtering. We use Netfilter for that (3.3+).
        ip46tables -t raw -N RPFILTER
        ip46tables -t raw -A RPFILTER -m rpfilter -j RETURN
        iptables   -t raw -A RPFILTER -d 255.255.255.255 -p udp --sport bootpc --dport bootps -j RETURN
        ip6tables  -t raw -A RPFILTER -m rpfilter --accept-local -m addrtype --dst-type MULTICAST -j DROP
        ip46tables -t raw -A RPFILTER -m limit --limit 5/s --limit-burst 5 \
                   -j LOG --log-prefix "NF: rpfilter: " --log-level warning
        ip46tables -t raw -A RPFILTER -j DROP
        ip46tables -t raw -A PREROUTING -i eth0 -j RPFILTER

        # VM could access BGP/BFD. There is TTL security, but better safe than sorry.
        ip46tables -N BGP-BFD
        ip46tables -A INPUT -p tcp --dport bgp -j BGP-BFD
        ip46tables -A INPUT -p tcp --dport 3784 -j BGP-BFD
        ip46tables -A INPUT -p tcp --dport 4784 -j BGP-BFD
        iptables -A BGP-BFD -s 198.51.100.0/24 -m ttl --ttl-eq 255 -j ACCEPT
        iptables -A BGP-BFD -s 172.22.15.0/24 -m ttl --ttl-eq 255 -j ACCEPT
        ip6tables -A BGP-BFD -s 2001:db8:c633:6400::/63 -m hl --hl-eq 255 -j ACCEPT
        ip46tables -A BGP-BFD -m limit --limit 5/s --limit-burst 5 \
                   -j LOG --log-prefix "NF: BGP/BFD: " --log-level warning
        ip46tables -A BGP-BFD -j DROP

        # Don't accept redirects and don't generate them (we don't
        # control how much time it takes for them to expire). As a
        # router, we should not accept redirects, but better safe than
        # sorry.
        # accept_redirects is "AND" when forwarding is enabled
        sysctl -qw net.ipv4.conf.all.accept_redirects=0
        sysctl -qw net.ipv6.conf.all.accept_redirects=0
        # send_redirects is "OR"
        sysctl -qw net.ipv4.conf.all.send_redirects=0
        sysctl -qw net.ipv4.conf.default.send_redirects=0
        sysctl -qw net.ipv4.conf.eth0.send_redirects=0
        sysctl -qw net.ipv4.conf.eth1/public.send_redirects=0
        sysctl -qw net.ipv4.conf.eth2/public.send_redirects=0
        # Unfortunately, not possible to disable that for IPv6.
        ip6tables -A OUTPUT -o eth0 -p ipv6-icmp --icmpv6-type redirect -j DROP

        # We do ARP proxying
        sysctl -qw net.ipv4.conf.eth0.proxy_arp=1
        sysctl -qw net.ipv4.conf.eth1/public.proxy_arp=1
        sysctl -qw net.ipv4.conf.eth2/public.proxy_arp=1
        sysctl -qw net.ipv4.neigh.eth0.proxy_delay=0

        # For IPv6, we use ndppd. Being stateless, it's safe
        # enough. It may answer requests we don't have routes for, but
        # that's not our problem.

        # Use a public routing table and a private one
        ip rule add iif eth0         lookup 90   priority 20
        ip rule add iif eth0         unreachable priority 21
        ip rule add iif eth1.public  lookup 90   priority 22
        ip rule add iif eth1.public  unreachable priority 23
        ip rule add iif eth2.public  lookup 90   priority 24
        ip rule add iif eth2.public  unreachable priority 25
        ip rule add iif eth1.private lookup 20   priority 26
        ip rule add iif eth1.private unreachable priority 27
        ip rule add iif eth2.private lookup 20   priority 28
        ip rule add iif eth2.private unreachable priority 29
        # For local lookups, use private, then public, then fallback to main
        ip rule add iif lo lookup main priority 51
        ip rule add iif lo lookup 20   priority 52
        ip rule add iif lo lookup 90   priority 53 # Last: has a default
        ip rule add unreachable        priority 100

        # Same for IPv6, less important since we don't have private
        # stuff, but link local addresses may still be used.
        ip -6 rule add iif eth0         lookup 90   priority 20
        ip -6 rule add iif eth0         unreachable priority 21
        ip -6 rule add iif eth1.public  lookup 90   priority 22
        ip -6 rule add iif eth1.public  unreachable priority 23
        ip -6 rule add iif eth2.public  lookup 90   priority 24
        ip -6 rule add iif eth2.public  unreachable priority 25
        ip -6 rule add iif lo lookup main priority 51
        ip -6 rule add iif lo lookup 90   priority 53 # Last: has a default
        ip -6 rule add unreachable        priority 100

        # Add routes to VM. Of course, it should be done by some kind
        # of automatic registration process.
        case ${uts#HV} in
            1)
                    ip route add 203.0.113.1/32 dev eth0 table 90
                    ip route add 203.0.113.2/32 dev eth0 table 90
                    ip -6 route add 2001:db8:cb00:7100:5254:33ff:fe00:4/128 dev eth0 table 90
                    ip -6 route add 2001:db8:cb00:7100:5254:33ff:fe00:5/128 dev eth0 table 90
                    ;;
            2)
                    ip route add 203.0.113.3/32 dev eth0 table 90
                    ip -6 route add 2001:db8:cb00:7100:5254:33ff:fe00:9/128 dev eth0 table 90
                    ;;
            3)
                    ip route add 203.0.113.4/32 dev eth0 table 90
                    ip -6 route add 2001:db8:cb00:7100:5254:33ff:fe00:d/128 dev eth0 table 90
                    ;;
        esac

        # We are a router
        sysctl -qw net.ipv4.ip_forward=1
        sysctl -qw net.ipv6.conf.all.forwarding=1

        service bird
        service radvd radvd.HV.conf
        service ndppd ndppd.HV.conf
        ;;
    RR*)
        ip link add name eth0.public link eth0 type vlan id 90
        ip link add name eth0.private link eth0 type vlan id 20
        ip link set up dev eth0.public
        ip link set up dev eth0.private

        ip addr add 198.51.100.${uts#RR}26/25 dev eth0.public
        ip addr add 172.22.15.${uts#RR}26/25 dev eth0.private
        ip -6 addr add 2001:db8:c633:640$((${uts#RR} - 1))::26/120 dev eth0.public

        service bird
        ;;
    VM*)
        # Each VM believes it is on a L2 network
        ip addr add 203.0.113.${uts#VM}/24 dev eth0
        ip route add default via 203.0.113.254 dev eth0

        # For IPv6, they will get RA
        ;;

    internet)
        ip link add name eth0.public link eth0 type vlan id 90
        ip link add name eth1.public link eth1 type vlan id 90
        ip link set up dev eth0.public
        ip link set up dev eth1.public

        # For ECMP routing
        ip addr add 198.51.100.1/25 dev eth0.public
        ip addr add 198.51.100.254/25 dev eth1.public
        ip -6 addr add 2001:db8:c633:6400::ff/120 dev eth0.public
        ip -6 addr add 2001:db8:c633:6401::ff/120 dev eth1.public

        # Use the public table for everything. Fallback to main is
        # automatic.
        ip rule add iif lo lookup main priority 51
        ip rule add iif lo lookup 90   priority 53 # Last: has a default
        ip -6 rule add iif lo lookup main priority 51
        ip -6 rule add iif lo lookup 90   priority 53 # Last: has a default

        # We are a router
        sysctl -qw net.ipv4.ip_forward=1
        sysctl -qw net.ipv6.conf.all.forwarding=1
        service bird

        # "Internet"
        ip addr add 8.8.8.8/32 dev dummy0
        ip -6 addr add 2001:4860:4860::8888/128 dev dummy0
        ;;
esac

service nginx
